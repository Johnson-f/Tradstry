---
description: Authentication and JWT handling patterns
---

# Authentication Patterns

## JWT Token Validation
The application uses Supabase JWT tokens for authentication. Key components:

- **Config**: [turso/config.rs](mdc:src/turso/config.rs) - Supabase configuration
- **Auth Logic**: [turso/auth.rs](mdc:src/turso/auth.rs) - JWT validation functions
- **Client**: [turso/client.rs](mdc:src/turso/client.rs) - Database client with user isolation

## Authentication Flow
1. Extract JWT token from `Authorization: Bearer <token>` header
2. Validate token with Supabase using `validate_supabase_jwt_token()`
3. Extract user claims from JWT payload
4. Use `claims.sub` as the user ID for database operations

## Helper Functions
Use these authentication helpers in route handlers:

```rust
// Get authenticated user from request
let claims = get_authenticated_user(&req, &supabase_config).await?;

// Get user-specific database connection
let conn = get_user_database_connection(&claims.sub, &turso_client).await?;
```

## JWT Claims Structure
```rust
pub struct SupabaseClaims {
    pub sub: String,        // User ID
    pub email: String,      // User email
    pub exp: i64,          // Expiration timestamp
    pub iat: i64,          // Issued at timestamp
    // ... other fields
}
```

## Error Handling
- Return `401 Unauthorized` for invalid/missing tokens
- Log authentication failures for debugging
- Handle token expiration gracefully
- Validate token format before processing

## Security Considerations
- Always validate tokens with Supabase (don't trust client-side validation)
- Use HTTPS in production
- Implement proper CORS policies
- Log security events for monitoring
- Handle token refresh if needed

## Database User Isolation
- All database operations must be scoped to the authenticated user
- Use `user_id` field in all queries to prevent data leakage
- Validate user ownership before allowing modifications
- Use user-specific database connections when available