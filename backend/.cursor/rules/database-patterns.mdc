---
description: Database operations and patterns
---

# Database Patterns

## Database Setup
The application uses Turso (LibSQL) as the primary database with SQLx for queries:

- **Client**: [turso/client.rs](mdc:src/turso/client.rs) - Main database client
- **Connection Management**: Handles user-specific database connections
- **Migration Support**: SQLx for schema management

## Connection Patterns
```rust
// Get user-specific database connection
let conn = get_user_database_connection(&claims.sub, &turso_client).await?;

// Use connection for queries
let result = sqlx::query("SELECT * FROM table WHERE user_id = ?")
    .bind(&claims.sub)
    .fetch_all(&conn)
    .await?;
```

## Query Patterns
- **Parameterized Queries**: Always use `?` placeholders to prevent SQL injection
- **User Isolation**: Include `user_id = ?` in WHERE clauses for data security
- **Error Handling**: Use `Result<T, sqlx::Error>` for database operations
- **Transactions**: Use transactions for multi-step operations

## Common Query Patterns
```rust
// Create with RETURNING
let row = sqlx::query("INSERT INTO table (user_id, field) VALUES (?, ?) RETURNING *")
    .bind(&user_id)
    .bind(&value)
    .fetch_one(&conn)
    .await?;

// Find with optional filters
let mut sql = "SELECT * FROM table WHERE user_id = ?".to_string();
if let Some(filter) = query.filter {
    sql.push_str(" AND field = ?");
}
let rows = sqlx::query(&sql)
    .bind(&user_id)
    .bind_optional(&query.filter)
    .fetch_all(&conn)
    .await?;

// Update with conditional fields
let row = sqlx::query("UPDATE table SET field = COALESCE(?, field) WHERE id = ? AND user_id = ? RETURNING *")
    .bind(&new_value)
    .bind(&id)
    .bind(&user_id)
    .fetch_optional(&conn)
    .await?;
```

## Pagination
```rust
// Add LIMIT and OFFSET for pagination
let sql = format!("{} LIMIT ? OFFSET ?", base_query);
let rows = sqlx::query(&sql)
    .bind(&user_id)
    .bind(limit)
    .bind(offset)
    .fetch_all(&conn)
    .await?;
```

## Error Handling
- Log database errors with context
- Handle connection failures gracefully
- Use proper HTTP status codes for database errors
- Implement retry logic for transient failures

## Performance Considerations
- Use indexes on frequently queried fields
- Implement proper pagination to avoid large result sets
- Use prepared statements for repeated queries
- Monitor query performance and optimize as needed