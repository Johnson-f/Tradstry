<!-- 139d57f4-c916-4e0c-bca1-b41e854bf05a c89bf421-714b-4617-986e-5e3986348290 -->
# Trade-Linked Notes with AI Processing

## 1) Schema Updates (backend/src/turso/schema.rs)

- Modify `trade_notes` to link to trades:
- Add `trade_type TEXT CHECK ('stock'|'option') NOT NULL`
- Add `stock_trade_id INTEGER NULL` and `option_trade_id INTEGER NULL`
- Add constraint: exactly one of `stock_trade_id` or `option_trade_id` is set
- Add FKs:
  - `FOREIGN KEY (stock_trade_id) REFERENCES stocks(id) ON DELETE CASCADE`
  - `FOREIGN KEY (option_trade_id) REFERENCES options(id) ON DELETE CASCADE`
- Indexes:
- `idx_trade_notes_stock_trade_id`, `idx_trade_notes_option_trade_id`
- Keep `idx_trade_notes_updated_at`
- Trigger: keep `update_trade_notes_timestamp`
- Migration path: recreate table if required, copy over compatible columns; ensure ON DELETE CASCADE works.

## 2) Cache Layer for Notes

- Add a small in-memory LRU cache in the Rust backend (per-process) for note drafts keyed by `(user_id, trade_type, trade_id)` with TTL (e.g., 5 minutes). Feature flag to swap to Redis later.
- Cache write after AI processing; read-through on GET.

## 3) AI Processing Pipeline (sync for v1)

- Service `ai_notes_service.rs`:
- `analyze_note(text, context)` → returns enriched payload: tags, summary, actions; store raw + ai_metadata.
- Use existing AI infra patterns (see `ai_insights`, `chat_sessions`) for authentication and rate limiting.
- Store AI metadata with the note row: add `ai_metadata TEXT` (JSON) column to `trade_notes`.

## 4) Routes

- New module `backend/src/routes/trade_notes.rs` with:
- `POST /api/trades/{type}/{id}/notes` → create/update note for a trade; body: `{ content }`.
- `GET /api/trades/{type}/{id}/notes` → fetch note.
- `DELETE /api/trades/{type}/{id}/notes` → delete note.
- Middleware: existing auth/JWT.
- The POST flow:

1. Validate trade exists (stocks/options table)
2. Run AI analysis (sync for v1)
3. Write to cache
4. Upsert into `trade_notes` (by unique key on trade)

## 5) Service Layer

- `service/trade_notes_service.rs`:
- `upsert_trade_note(user_id, trade_ref, content) -> TradeNote`
- `get_trade_note(user_id, trade_ref) -> Option<TradeNote>` (cache-first)
- `delete_trade_note(user_id, trade_ref) -> bool`
- `trade_ref = { trade_type: 'stock'|'option', trade_id: i64 }`.

## 6) Unique Constraint

- Add a unique index so each trade has at most one note:
- Unique on `(stock_trade_id)` where not null, and on `(option_trade_id)` where not null (two separate partial uniques via triggers or check, or emulate by constraints and insert logic).

## 7) Deletion Behavior

- Already handled by `ON DELETE CASCADE` on FKs; no manual cleanup needed when a trade is deleted.

## 8) Expected Frontend Interaction

- Frontend sends content as the user types (debounced) to `POST /api/trades/{type}/{id}/notes`.
- Backend processes via AI, writes to cache, persists to DB; on error, cache is still updated for UX continuity and DB retry can be added later (optional background retry).

## 9) Testing

- Migration test: create trade → create note → delete trade → note should be gone.
- Route tests for stock and option types.
- AI service mocked in tests.

## 10) Rollout

- Add schema migration bump in `get_current_schema_version` and `get_expected_schema`.
- Deploy backend, then enable frontend note autosave.

### To-dos

- [ ] Update trade_notes schema with trade link FKs + ai_metadata + indexes
- [ ] Implement TradeNotesService with upsert/get/delete and cache
- [ ] Create ai_notes_service to analyze notes and return metadata
- [ ] Add trade_notes routes (POST/GET/DELETE) under /api/trades/{type}/{id}/notes
- [ ] Bump schema version and implement safe migration path
- [ ] Add integration tests for cascade delete and route behaviors