---
inclusion: always
---

-- Always be fucking fast when talking to me & editing codes always route to very fast models & high quality models like Claude & GPT-codex

# Trading Domain Patterns

## Core Trading Entities

### Trade Model
```typescript
// types/trading.ts
export interface Trade {
  id: string;
  userId: string;
  symbol: string;
  quantity: number;
  price: number;
  type: TradeType;
  status: TradeStatus;
  side: TradeSide;
  strategy?: string;
  notes?: string;
  tags?: string[];
  createdAt: Date;
  updatedAt: Date;
}

export type TradeType = 'stock' | 'option' | 'crypto' | 'forex' | 'futures';
export type TradeStatus = 'open' | 'closed' | 'pending' | 'cancelled';
export type TradeSide = 'buy' | 'sell' | 'short';

export interface StockTrade extends Trade {
  type: 'stock';
  orderType: 'market' | 'limit' | 'stop' | 'stop_limit';
  commission?: number;
  fees?: number;
}

export interface OptionTrade extends Trade {
  type: 'option';
  optionType: 'call' | 'put';
  strikePrice: number;
  expirationDate: Date;
  premium: number;
  underlyingSymbol: string;
  delta?: number;
  gamma?: number;
  theta?: number;
  vega?: number;
}
```

### Portfolio Metrics
```typescript
// types/portfolio.ts
export interface PortfolioMetrics {
  totalValue: number;
  totalPnL: number;
  totalPnLPercent: number;
  dayPnL: number;
  dayPnLPercent: number;
  winRate: number;
  profitFactor: number;
  sharpeRatio: number;
  maxDrawdown: number;
  totalTrades: number;
  winningTrades: number;
  losingTrades: number;
  averageWin: number;
  averageLoss: number;
  largestWin: number;
  largestLoss: number;
}

export interface Position {
  symbol: string;
  quantity: number;
  averagePrice: number;
  currentPrice: number;
  marketValue: number;
  unrealizedPnL: number;
  unrealizedPnLPercent: number;
  realizedPnL: number;
  lastUpdated: Date;
}
```

## Trading Strategies

### Strategy Pattern Implementation
```typescript
// strategies/base-strategy.ts
export abstract class TradingStrategy {
  abstract name: string;
  abstract description: string;

  abstract shouldEnter(marketData: MarketData): boolean;
  abstract shouldExit(position: Position, marketData: MarketData): boolean;
  abstract calculatePositionSize(accountValue: number, riskPercent: number): number;

  validateEntry(trade: Trade): ValidationResult {
    const errors: string[] = [];

    if (!trade.symbol) {
      errors.push('Symbol is required');
    }

    if (trade.quantity <= 0) {
      errors.push('Quantity must be positive');
    }

    if (trade.price <= 0) {
      errors.push('Price must be positive');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// strategies/momentum-strategy.ts
export class MomentumStrategy extends TradingStrategy {
  name = 'Momentum';
  description = 'Buy on upward momentum, sell on downward momentum';

  shouldEnter(marketData: MarketData): boolean {
    return marketData.rsi < 30 && marketData.macd > 0;
  }

  shouldExit(position: Position, marketData: MarketData): boolean {
    return marketData.rsi > 70 || marketData.macd < 0;
  }

  calculatePositionSize(accountValue: number, riskPercent: number): number {
    return (accountValue * riskPercent) / 100;
  }
}
```

## Risk Management

### Position Sizing
```typescript
// risk/position-sizing.ts
export class PositionSizer {
  static calculateByRisk(
    accountValue: number,
    entryPrice: number,
    stopLoss: number,
    riskPercent: number
  ): number {
    const riskAmount = accountValue * (riskPercent / 100);
    const riskPerShare = Math.abs(entryPrice - stopLoss);
    return Math.floor(riskAmount / riskPerShare);
  }

  static calculateByVolatility(
    accountValue: number,
    symbol: string,
    volatility: number,
    riskPercent: number
  ): number {
    const riskAmount = accountValue * (riskPercent / 100);
    const volatilityMultiplier = 1 / (volatility / 100);
    return Math.floor(riskAmount * volatilityMultiplier);
  }

  static calculateByKelly(
    winRate: number,
    averageWin: number,
    averageLoss: number
  ): number {
    const winLossRatio = averageWin / averageLoss;
    const kellyPercent = (winRate * winLossRatio - (1 - winRate)) / winLossRatio;
    return Math.max(0, Math.min(kellyPercent, 0.25)); // Cap at 25%
  }
}
```

### Risk Metrics
```typescript
// risk/risk-metrics.ts
export class RiskCalculator {
  static calculateVaR(
    positions: Position[],
    confidenceLevel: number = 0.95,
    timeHorizon: number = 1
  ): number {
    // Value at Risk calculation
    const portfolioValue = positions.reduce((sum, pos) => sum + pos.marketValue, 0);
    const volatility = this.calculatePortfolioVolatility(positions);
    const zScore = this.getZScore(confidenceLevel);

    return portfolioValue * volatility * zScore * Math.sqrt(timeHorizon);
  }

  static calculateMaxDrawdown(trades: Trade[]): number {
    let peak = 0;
    let maxDrawdown = 0;
    let runningPnL = 0;

    for (const trade of trades) {
      runningPnL += trade.realizedPnL || 0;
      peak = Math.max(peak, runningPnL);
      const drawdown = peak - runningPnL;
      maxDrawdown = Math.max(maxDrawdown, drawdown);
    }

    return maxDrawdown;
  }

  static calculateSharpeRatio(
    returns: number[],
    riskFreeRate: number = 0.02
  ): number {
    const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const excessReturn = avgReturn - riskFreeRate;
    const volatility = this.calculateStandardDeviation(returns);

    return volatility > 0 ? excessReturn / volatility : 0;
  }
}
```

## Market Data Integration

### Market Data Service
```typescript
// services/market-data-service.ts
export class MarketDataService {
  private cache = new Map<string, MarketData>();
  private cacheTimeout = 60000; // 1 minute

  async getRealTimeData(symbol: string): Promise<MarketData> {
    const cached = this.cache.get(symbol);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached;
    }

    const data = await this.fetchFromAPI(symbol);
    this.cache.set(symbol, data);
    return data;
  }

  async getHistoricalData(
    symbol: string,
    period: '1d' | '5d' | '1mo' | '3mo' | '6mo' | '1y' | '2y' | '5y' | '10y' | 'ytd' | 'max',
    interval: '1m' | '2m' | '5m' | '15m' | '30m' | '60m' | '90m' | '1h' | '1d' | '5d' | '1wk' | '1mo' | '3mo' = '1d'
  ): Promise<HistoricalData[]> {
    // Implementation for fetching historical data
    return [];
  }

  private async fetchFromAPI(symbol: string): Promise<MarketData> {
    // Implementation for real-time data fetching
    return {
      symbol,
      price: 0,
      change: 0,
      changePercent: 0,
      volume: 0,
      timestamp: Date.now(),
      // ... other fields
    };
  }
}
```

## Performance Analytics

### Trade Analysis
```typescript
// analytics/trade-analytics.ts
export class TradeAnalytics {
  static analyzeTrades(trades: Trade[]): TradeAnalysis {
    const closedTrades = trades.filter(t => t.status === 'closed');
    const winningTrades = closedTrades.filter(t => (t.realizedPnL || 0) > 0);
    const losingTrades = closedTrades.filter(t => (t.realizedPnL || 0) < 0);

    const totalPnL = closedTrades.reduce((sum, t) => sum + (t.realizedPnL || 0), 0);
    const winRate = closedTrades.length > 0 ? winningTrades.length / closedTrades.length : 0;

    const averageWin = winningTrades.length > 0
      ? winningTrades.reduce((sum, t) => sum + (t.realizedPnL || 0), 0) / winningTrades.length
      : 0;

    const averageLoss = losingTrades.length > 0
      ? losingTrades.reduce((sum, t) => sum + (t.realizedPnL || 0), 0) / losingTrades.length
      : 0;

    const profitFactor = averageLoss !== 0 ? Math.abs(averageWin / averageLoss) : 0;

    return {
      totalTrades: closedTrades.length,
      winningTrades: winningTrades.length,
      losingTrades: losingTrades.length,
      winRate,
      totalPnL,
      averageWin,
      averageLoss,
      profitFactor,
      largestWin: Math.max(...winningTrades.map(t => t.realizedPnL || 0), 0),
      largestLoss: Math.min(...losingTrades.map(t => t.realizedPnL || 0), 0),
    };
  }

  static calculateDrawdowns(trades: Trade[]): DrawdownPeriod[] {
    const drawdowns: DrawdownPeriod[] = [];
    let peak = 0;
    let currentDrawdown = 0;
    let drawdownStart: Date | null = null;
    let runningPnL = 0;

    for (const trade of trades) {
      runningPnL += trade.realizedPnL || 0;

      if (runningPnL > peak) {
        peak = runningPnL;
        if (currentDrawdown > 0) {
          drawdowns.push({
            start: drawdownStart!,
            end: trade.updatedAt,
            depth: currentDrawdown,
            duration: trade.updatedAt.getTime() - drawdownStart!.getTime(),
          });
          currentDrawdown = 0;
          drawdownStart = null;
        }
      } else {
        const drawdown = peak - runningPnL;
        if (drawdown > currentDrawdown) {
          currentDrawdown = drawdown;
          if (!drawdownStart) {
            drawdownStart = trade.updatedAt;
          }
        }
      }
    }

    return drawdowns;
  }
}
```

## Journal and Notes

### Trade Journal
```typescript
// journal/trade-journal.ts
export interface TradeJournalEntry {
  id: string;
  tradeId: string;
  userId: string;
  entry: string;
  tags: string[];
  emotions: Emotion[];
  lessons: string[];
  screenshots?: string[];
  createdAt: Date;
  updatedAt: Date;
}

export interface Emotion {
  type: 'fear' | 'greed' | 'confidence' | 'doubt' | 'excitement' | 'frustration';
  intensity: number; // 1-10
  description?: string;
}

export class TradeJournalService {
  async createEntry(
    tradeId: string,
    userId: string,
    entry: string,
    tags: string[] = [],
    emotions: Emotion[] = []
  ): Promise<TradeJournalEntry> {
    return {
      id: generateId(),
      tradeId,
      userId,
      entry,
      tags,
      emotions,
      lessons: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  }

  async analyzeEmotions(entries: TradeJournalEntry[]): Promise<EmotionAnalysis> {
    const emotionCounts = new Map<string, number>();
    const emotionIntensities = new Map<string, number[]>();

    for (const entry of entries) {
      for (const emotion of entry.emotions) {
        emotionCounts.set(emotion.type, (emotionCounts.get(emotion.type) || 0) + 1);

        if (!emotionIntensities.has(emotion.type)) {
          emotionIntensities.set(emotion.type, []);
        }
        emotionIntensities.get(emotion.type)!.push(emotion.intensity);
      }
    }

    const averageIntensities = new Map<string, number>();
    for (const [emotion, intensities] of emotionIntensities) {
      const avg = intensities.reduce((sum, i) => sum + i, 0) / intensities.length;
      averageIntensities.set(emotion, avg);
    }

    return {
      totalEntries: entries.length,
      emotionCounts: Object.fromEntries(emotionCounts),
      averageIntensities: Object.fromEntries(averageIntensities),
    };
  }
}
```

## Best Practices

1. **Always validate trade data before execution**
2. **Implement proper risk management rules**
3. **Use position sizing based on account risk**
4. **Maintain detailed trade journals**
5. **Calculate and monitor key performance metrics**
6. **Implement proper error handling for market data**
7. **Use caching for frequently accessed market data**
8. **Implement proper backtesting for strategies**
9. **Monitor drawdowns and risk metrics**
10. **Maintain audit trails for all trading activities**
