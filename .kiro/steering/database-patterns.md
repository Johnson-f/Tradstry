---
inclusion: fileMatch
fileMatchPattern: ['*.ts', '*.rs', '*.sql']
---

-- Always be fucking fast when talking to me & editing codes always route to very fast models & high quality models like Claude & GPT-codex

# Database Patterns & ORM Usage

## Frontend Database (Browser SQLite + Drizzle)

### Schema Definition
```typescript
// lib/drizzle/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';
import { createId } from '@paralleldrive/cuid2';

export const tradesTable = sqliteTable('trades', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  userId: text('user_id').notNull(),
  symbol: text('symbol').notNull(),
  quantity: real('quantity').notNull(),
  price: real('price').notNull(),
  type: text('type', { enum: ['stock', 'option', 'crypto'] }).notNull(),
  status: text('status', { enum: ['open', 'closed', 'pending'] }).notNull().default('open'),
  createdAt: text('created_at').notNull().$defaultFn(() => new Date().toISOString()),
  updatedAt: text('updated_at').notNull().$defaultFn(() => new Date().toISOString()),
});

export const notesTable = sqliteTable('notes', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  userId: text('user_id').notNull(),
  name: text('name').notNull(),
  content: text('content').default(''),
  isFavorite: integer('is_favorite', { mode: 'boolean' }).default(false),
  isDeleted: integer('is_deleted', { mode: 'boolean' }).default(false),
  createdAt: text('created_at').notNull().$defaultFn(() => new Date().toISOString()),
  updatedAt: text('updated_at').notNull().$defaultFn(() => new Date().toISOString()),
});

// Infer types
export type Trade = typeof tradesTable.$inferSelect;
export type NewTrade = typeof tradesTable.$inferInsert;
export type Note = typeof notesTable.$inferSelect;
export type NewNote = typeof notesTable.$inferInsert;
```

### Database Operations Hook
```typescript
// lib/drizzle/operations.ts
import { useBrowserDatabase } from '@/lib/browser-database';
import { eq, and, desc, asc, count, sql, like } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/sqlite-proxy';

export function useTradesDatabase(userId: string) {
  const { isInitialized, execute, query } = useBrowserDatabase({
    dbName: 'tradistry-trades',
    enablePersistence: true,
    initSql: [
      `CREATE TABLE IF NOT EXISTS trades (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        symbol TEXT NOT NULL,
        quantity REAL NOT NULL,
        price REAL NOT NULL,
        type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'open',
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      )`,
      `CREATE INDEX IF NOT EXISTS idx_trades_user_id ON trades(user_id)`,
      `CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)`,
      `CREATE INDEX IF NOT EXISTS idx_trades_created_at ON trades(created_at)`
    ],
    autoInit: true
  });

  // Create Drizzle instance
  const db = drizzle(async (sql, params, method) => {
    try {
      if (method === 'run') {
        const result = await execute(sql, params);
        return { rows: [], meta: {} };
      } else {
        const result = await query(sql, params);
        return {
          rows: result.values.map(row =>
            result.columns.reduce((obj, col, idx) => ({ ...obj, [col]: row[idx] }), {})
          )
        };
      }
    } catch (error) {
      throw error;
    }
  });

  const insertTrade = useCallback(async (trade: Omit<NewTrade, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Trade> => {
    const id = createId();
    const now = new Date().toISOString();

    const insertSql = `
      INSERT INTO trades (id, user_id, symbol, quantity, price, type, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    await execute(insertSql, [
      id, userId, trade.symbol, trade.quantity, trade.price,
      trade.type, trade.status || 'open', now, now
    ]);

    // Return the inserted trade
    const result = await query('SELECT * FROM trades WHERE id = ? AND user_id = ?', [id, userId]);
    return result.values[0] as Trade;
  }, [userId, execute, query]);

  const getTrades = useCallback(async (options?: {
    limit?: number;
    offset?: number;
    symbol?: string;
    status?: string;
  }): Promise<Trade[]> => {
    const { limit = 100, offset = 0, symbol, status } = options || {};

    let whereClause = 'WHERE user_id = ?';
    const params: any[] = [userId];

    if (symbol) {
      whereClause += ' AND symbol = ?';
      params.push(symbol);
    }

    if (status) {
      whereClause += ' AND status = ?';
      params.push(status);
    }

    const sql = `
      SELECT * FROM trades
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?
    `;

    params.push(limit, offset);
    const result = await query(sql, params);
    return result.values as Trade[];
  }, [userId, query]);

  return {
    isInitialized,
    insertTrade,
    getTrades,
    // ... other operations
  };
}
```

## Backend Database (Turso + libSQL)

### Database Client
```rust
// src/turso/client.rs
use anyhow::{Context, Result};
use libsql::{Connection, Database, Builder};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub struct TursoClient {
    config: TursoConfig,
    registry_db: Database,
    http_client: Client,
}

impl TursoClient {
    pub async fn new(config: TursoConfig) -> Result<Self> {
        let registry_db = Builder::new_remote(
            config.database_url.clone(),
            config.auth_token.clone(),
        )
        .build()
        .await
        .context("Failed to connect to registry database")?;

        Ok(Self {
            config,
            registry_db,
            http_client: Client::new(),
        })
    }

    pub async fn get_user_database_connection(
        &self,
        user_id: &str,
    ) -> Result<Option<Connection>> {
        // Get user database info from registry
        let mut stmt = self.registry_db
            .prepare("SELECT db_url, db_token FROM user_databases WHERE user_id = ?")?;

        let mut rows = stmt.query([user_id])?;
        if let Some(row) = rows.next()? {
            let db_url: String = row.get(0)?;
            let db_token: String = row.get(1)?;

            let user_db = Builder::new_remote(db_url, db_token)
                .build()
                .await
                .context("Failed to connect to user database")?;

            Ok(Some(user_db.connect()?))
        } else {
            Ok(None)
        }
    }

    pub async fn create_user_database(&self, user_id: &str, email: &str) -> Result<()> {
        // Create new database via Turso API
        let response = self.http_client
            .post("https://api.turso.tech/v1/databases")
            .header("Authorization", format!("Bearer {}", self.config.auth_token))
            .json(&serde_json::json!({
                "name": format!("user-{}", user_id),
                "primaryRegion": "iad"
            }))
            .send()
            .await?;

        let db_info: TursoCreateDbResponse = response.json().await?;

        // Create database token
        let token_response = self.http_client
            .post(&format!("https://api.turso.tech/v1/databases/{}/tokens", db_info.database.name))
            .header("Authorization", format!("Bearer {}", self.config.auth_token))
            .send()
            .await?;

        let token_info: TursoTokenResponse = token_response.json().await?;

        // Store in registry
        self.registry_db.execute(
            "INSERT INTO user_databases (user_id, email, db_name, db_url, db_token, created_at, updated_at)
             VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))",
            params![
                user_id,
                email,
                db_info.database.name,
                format!("https://{}.turso.io", db_info.database.hostname),
                token_info.jwt
            ],
        )?;

        // Initialize user database schema
        self.initialize_user_database(&db_info.database.hostname, &token_info.jwt).await?;

        Ok(())
    }

    async fn initialize_user_database(&self, hostname: &str, token: &str) -> Result<()> {
        let user_db = Builder::new_remote(
            format!("https://{}.turso.io", hostname),
            token.to_string(),
        )
        .build()
        .await?;

        let conn = user_db.connect()?;

        // Create tables
        conn.execute(
            "CREATE TABLE IF NOT EXISTS trades (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                symbol TEXT NOT NULL,
                quantity REAL NOT NULL,
                price REAL NOT NULL,
                type TEXT NOT NULL,
                status TEXT NOT NULL DEFAULT 'open',
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS notes (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                name TEXT NOT NULL,
                content TEXT DEFAULT '',
                is_favorite INTEGER DEFAULT 0,
                is_deleted INTEGER DEFAULT 0,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )",
            [],
        )?;

        // Create indexes
        conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_user_id ON trades(user_id)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)", [])?;
        conn.execute("CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id)", [])?;

        Ok(())
    }
}
```

### Model Operations
```rust
// src/models/trade.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use libsql::{Connection, params};

impl Trade {
    pub async fn create(
        conn: &Connection,
        user_id: &str,
        request: CreateTradeRequest,
    ) -> Result<Self> {
        let id = uuid::Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();

        conn.execute(
            "INSERT INTO trades (id, user_id, symbol, quantity, price, type, status, created_at, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            params![
                id,
                user_id,
                request.symbol,
                request.quantity,
                request.price,
                serde_json::to_string(&request.trade_type)?,
                serde_json::to_string(&TradeStatus::Open)?,
                now,
                now
            ],
        )?;

        Self::find_by_id(conn, &id).await
    }

    pub async fn find_by_user_id(
        conn: &Connection,
        user_id: &str,
        limit: Option<i64>,
        offset: Option<i64>,
    ) -> Result<Vec<Self>> {
        let limit = limit.unwrap_or(100);
        let offset = offset.unwrap_or(0);

        let mut stmt = conn.prepare(
            "SELECT * FROM trades WHERE user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?"
        )?;

        let mut rows = stmt.query(params![user_id, limit, offset])?;
        let mut trades = Vec::new();

        while let Some(row) = rows.next()? {
            trades.push(Self::from_row(row)?);
        }

        Ok(trades)
    }

    pub async fn update(
        conn: &Connection,
        id: &str,
        user_id: &str,
        updates: UpdateTradeRequest,
    ) -> Result<Self> {
        let mut set_clauses = Vec::new();
        let mut params = Vec::new();

        if let Some(symbol) = updates.symbol {
            set_clauses.push("symbol = ?");
            params.push(symbol);
        }

        if let Some(quantity) = updates.quantity {
            set_clauses.push("quantity = ?");
            params.push(quantity.to_string());
        }

        if let Some(price) = updates.price {
            set_clauses.push("price = ?");
            params.push(price.to_string());
        }

        if let Some(status) = updates.status {
            set_clauses.push("status = ?");
            params.push(serde_json::to_string(&status)?);
        }

        if set_clauses.is_empty() {
            return Self::find_by_id(conn, id).await;
        }

        set_clauses.push("updated_at = ?");
        params.push(Utc::now().to_rfc3339());
        params.push(id);
        params.push(user_id);

        let sql = format!(
            "UPDATE trades SET {} WHERE id = ? AND user_id = ?",
            set_clauses.join(", ")
        );

        conn.execute(&sql, params)?;
        Self::find_by_id(conn, id).await
    }

    pub async fn delete(conn: &Connection, id: &str, user_id: &str) -> Result<bool> {
        let result = conn.execute(
            "DELETE FROM trades WHERE id = ? AND user_id = ?",
            params![id, user_id],
        )?;

        Ok(result > 0)
    }
}
```

## Database Migrations

### Frontend Migrations
```typescript
// lib/drizzle/migrations.ts
export const migrations = [
  {
    version: 1,
    up: `
      CREATE TABLE IF NOT EXISTS trades (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        symbol TEXT NOT NULL,
        quantity REAL NOT NULL,
        price REAL NOT NULL,
        type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'open',
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_trades_user_id ON trades(user_id);
      CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol);
    `
  },
  {
    version: 2,
    up: `
      ALTER TABLE trades ADD COLUMN notes TEXT DEFAULT '';
    `
  }
];
```

### Backend Migrations
```sql
-- database/01_trades.sql
CREATE TABLE IF NOT EXISTS trades (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    symbol TEXT NOT NULL,
    quantity REAL NOT NULL,
    price REAL NOT NULL,
    type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'open',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_trades_user_id ON trades(user_id);
CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol);
CREATE INDEX IF NOT EXISTS idx_trades_created_at ON trades(created_at);

-- database/02_notes.sql
CREATE TABLE IF NOT EXISTS notes (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    name TEXT NOT NULL,
    content TEXT DEFAULT '',
    is_favorite INTEGER DEFAULT 0,
    is_deleted INTEGER DEFAULT 0,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at);
```

## Best Practices

1. **Use proper indexing for query performance**
2. **Implement connection pooling for backend databases**
3. **Use transactions for multi-step operations**
4. **Validate data at the database level with constraints**
5. **Use prepared statements to prevent SQL injection**
6. **Implement proper error handling for database operations**
7. **Use migrations for schema changes**
8. **Cache frequently accessed data**
9. **Monitor database performance and query execution times**
10. **Use database-specific optimizations (SQLite vs PostgreSQL)**
